## 职工管理系统需求（3.16更新V2）

### 1.1 类和功能

#### 1.1.1 类

基本职工类：职工号、姓名、职位（暂定职工、经理、老板三类）、职位任务

#### 1.1.2 功能

1.自动生成管理菜单									2.退出管理程序

3.增加职工信息											4.显示所有职工信息

5.读写已有职工信息（有一定格式）		6.查找/修改/删除职工信息

7.编号排序													8.清空现有数据（包括文档）

#### 1.1.3 细节

1.管理菜单利用switch函数，无限循环，并设置清屏功能，使每次打开界面都能看到菜单；

2.增加的职工信息在主函数全过程应都存在，读写功能应该在主体开始前和结束后进行；

3.排序的方式和查找的方式应该设置多种，比如工号、姓名、职位等等；

4.直接清空数据风险得考虑，因此设置密码和重复确认；

5.对不同情况的考察，没有数据增加/显示数据与正常不同；无文件和有文件读；清空数据文档也要清理；等等

### 1.2 问题

#### 1.2.1 确定基本类和拓展类

1.基本类中，关于职位和任务项，应该创建父类和子类，利用数据互通的道理对这块内容进行定义。因此拓展类的第一个就是职务类（父）和职工类、老板类、经理类（子）；在基本类中，此拓展类表现为一个父类指针即可自由切换不同职务；

2.对数据存储的形式，因为方便调用所有数据，必须建立一个长久使用的数组，并且能够对表顺序进行自动排列，这里使用了一个地址数组的方式，全局定义地址数组，在地址类包含数据指针和表序号两个元素，这样就形成第二个拓展类，足够支撑项目。

##### 1.2.1.1 全局数组定义

这里定义全局数组的方式如下：

```c++
address add1[100];//主函数
extern address add1[];//头文件拓展定义
```

刚开始，定义的是const/static数组，const导致值无法修改，static就是防止多文件使用而定义的，因此其实都不科学，拓展定义中，也不需要重新对数组长度定义，这样计算机已经能自动实现联机搜索了。

##### 1.2.1.2 数据析构问题

定义了两个拓展类，衍生的指针有数据类中的职务类指针和地址的数据类指针，因此析构函数两个类都存在即可。

##### 1.2.1.3 子子数据读取（√）

针对地址类中数据指针的职务指向，在读取时是这样读取的：

```c++
cout<<add1[0].b->ta->pos
```

这个问题目前还有待考证，因为为了不这样写，实际写法是：add1[0].b->pos指向职位，事实上和预期定义不太相符，拓展类把四个属性更新的，需要重新导入num和name，这个是一个管理系统有待改进的地方。

考证完成，具体是像上文列出的样子读取，添加了shuju中的指针task *ta；

#### 1.2.2 查找、删除、修改

查找方法应该识别数组中的指针是否为空，然后在对数据类进行判读；

在C++中，很方便的一个就是可以直接比较string类型是否相等，以及根据字母序列的ASCII码判读大小。

删除的方法是把删除项内存清除，指针指向后续的其他项内容，因为在数组定义中，a代表表序，所以不对a的序号进行调整操作。

修改其实很简单，将职位中的string改动即可，对于职务变动，可以使用不同子类填入父类信息中。

#### 1.2.3 排序方法

排序方法设置了四种：倒序排列、工号排列、姓名排列、职位排列

利用工号、姓名、职位可以快速整理表中数据；

若需要从后往前读，再执行一次倒序即可完成任务，这样排序会非常科学化。

#### 1.2.4 读写问题

刚开始是倾向于使用二进制进行读写实现的，但是二进制常常识别不出来，并不适合用在对成堆数据的读取，于是使用普通读取手段进行读取。

##### 1.2.4.1 写文件

```c++
void write1()
{
	int i = 0;
	ofstream ofs2;
	if (add1[0].b == NULL) return;
	ofs2.open("yuangong.txt", ios::out);
	for (i = 0; add1[i].b != NULL; i++)
		ofs2 << add1[i].b->num << "	" << add1[i].b->name
		<< "	" << add1[i].b->pos << "	" << add1[i].b->mission << endl;
	ofs2.close();
}
```

在写文件操作中，并没有遇到什么具体的问题，输出有效；因为害怕表部分导出问题，因此此处没有设计筛选，而是每次全导出。

##### 1.2.4.2 读文件

读文件中遇到了问题：

修改之前判读文件读完的方法是：

```c++
for (a = 0; ifs.get() != EOF; a++)
		{
			add1[a].a=a+1;
			add1[a].b = new shuju;
			ifs >> add1[a].b->num;
			ifs >> add1[a].b->name;
			ifs >> add1[a].b->pos;
			ifs >> add1[a].b->mission;
		}
```

这个判读方式出现问题的原因是：

（1）ifs.get()会把第一个字符吞掉，此后读入没有第一个字符；

（2）在写文件结尾的空行也被读入（EOF要“\n”结束后才读到），导致数据错误；

给出的建议是，修改读入方式为链式读取，只需要写的时候注意每行的数据个数即可：

```c++
while(ifs>>aa>>bb>>cc>>dd)
		{
			add1[a].a = a + 1;
			add1[a].b = new shuju;
			add1[a].b->num=aa;
			add1[a].b->name=bb;
			add1[a].b->pos=cc;
			add1[a].b->mission=dd;
			a++;
		}
```

#### 1.2.5 cin缺失

这个问题出现的原因是，在cin>>(int)的时候输入了char或者其它内容。

而做法有点类似c语言中的getchar()消除cin读取结果：

```c++
void cinwrong()
{
	while (cin.fail())
	{
		string num_input_string;
		cin.clear();
		cin >> num_input_string;
		cout << "输入的" << num_input_string << "格式错误，添加失败" << endl;
	}
}
```

数据类型错误的时候，cin不读入且执行，我们可以用这个函数消除错误。

### 2.1 改进内容

1.在版本号2中，修复了程序的存储数据类型；

2.在版本号3中，欲完善数据类型错误判读功能；

3.应该修复数组存取有限数据的问题。

### 3.1 黑马思考

他的程序是这么做的：

1.WorkerManager类：用来总管这个系统的类，包括各种职工管理系统的函数，职工人数和职工数组指针。

添加新数据的方法，这样可以多态调用类数据。

通过保留下的员工数，开辟新空间和新地址，对原有的存放空间做整体转移

```c++
int newSize = this->EmpNum + addNum;
		//开辟空间
		Worker** newSpace = new Worker * [newSize];
		//将原来的空间的数据拷贝到新空间上
		if (this->Emp_Arr != NULL)
		{
			for (int i = 0; i < this->EmpNum; i++)
			{
				newSpace[i] = this->Emp_Arr[i];
			}
		}
```

这种方法也比较利于管理，相比于把指针传入数组中，它对开辟的新数据大小不上限，在未知大小的情况下，更加符合项目要求。

第二，就是他的每个新建或者修改职位信息，职位信息做cout输出，省去了对这块空间的string大小，但是也有一个弊端，每次重新更换信息，不确定更换的是职工职位或者其它信息，他干脆把所有信息重新输入，这个优化没做好，有利有弊，可以看到，他在输出输入文件存储员工职位用int存储，文件可读性不足；

第三，在删除文件一步，它并没有删除彻底，而是重新写空白的方式，保留了一个空文档，不过，这也为他前面列举文件不存在、存在为空、存在且有数据买下了伏笔。



